{
  "posts": [
    {
      "content": "注：原文写于2020.11.15，当时写在洛谷博客上，现在搬run到博客园中……\r\n\r\n~~以下内容为反面教材~~\r\n\r\n# 前言\r\n2020年11月7日，我参加了CSP2020入门组的复赛。考完之后感觉很不好，洛谷评测230，结果出来是270，~~感觉一等是没有希望了~~，但不管怎么说吧，我还是应当好好分析一下这次考试的得失。\r\n\r\n# 试题分析\r\n\r\n## PART 1\r\n[优秀的拆分](https://www.luogu.com.cn/problem/P7071)\r\n\r\n这是一道大水题，据我们考前分析，历届CSP入门组复赛第一题的难度成递减趋势（看2019年第一题[数字游戏](https://www.luogu.com.cn/problem/P5660)就知道了）。~~本人当时做得也比较顺利，直接AC。~~\r\n\r\n这道题就是一道转二进制的题，多的不想说，直接贴代码（加了文件输入输出的原版代码）：\r\n```cpp\r\n#include<cstdio>\r\n\r\nint main(){\r\n\t\r\n\tfreopen(\"power.in\",\"r\",stdin);\r\n\tfreopen(\"power.out\",\"w\",stdout);\r\n\t\r\n\tint a;\r\n\tscanf(\"%d\",&a);\r\n\tif(a%2==1){\r\n\t\tprintf(\"-1\");\r\n\t\treturn 0;\r\n\t}\r\n\tint now=1;\r\n\twhile(now<=a)now*=2;\r\n\tnow/=2;\r\n\twhile(a>0){\r\n\t\tif(a>=now){\r\n\t\t\tprintf(\"%d \",now);\r\n\t\t\ta-=now;\r\n\t\t}\r\n\t\tnow/=2;\r\n\t}\r\n\t\r\n\treturn 0;\r\n}\r\n```\r\n\r\n## PART 2\r\n[直播获奖](https://www.luogu.com.cn/problem/P7072)\r\n\r\n~~相当于是半道水题~~。\r\n\r\n刚开始以为是排序题，一看数据规模，N到了10的5次方，O(N×N)的算法直接凉凉（某同学就是因为没看数据规模从而只剩40分）。\r\n\r\n再一看，每个选手的成绩为不超过600的正整数，于是乎，我想到了桶排。每输入一个成绩，对应的sum＋1，在从后往前扫一遍直到人数满足要求。复杂度为O(KN)，（K是一个不超过600的常数）。轻松AC。\r\n\r\n相较来看，比去年[公交换乘](https://www.luogu.com.cn/problem/P5661)至少从代码量上来说要简单得多。\r\n\r\n贴代码（同上，原版代码）：\r\n```cpp\r\n#include<cstdio>\r\n#define N 605\r\n\r\nint num,k,a,sum[N];\r\n\r\nint main(){\r\n\t\r\n\tfreopen(\"live.in\",\"r\",stdin);\r\n\tfreopen(\"live.out\",\"w\",stdout);\r\n\t\r\n\tscanf(\"%d%d\",&num,&k);\r\n\tfor(int i=1;i<=num;i++){\r\n\t\tscanf(\"%d\",&a);\r\n\t\tsum[a]++;\r\n\t\tint now=0,m=i*k/100>0?i*k/100:1;\r\n\t\tfor(int j=602;j>=0;j--){\r\n\t\t\tnow+=sum[j];\r\n\t\t\tif(now>=m){\r\n\t\t\t\tprintf(\"%d \",j);\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\treturn 0;\r\n}\r\n```\r\n\r\n## PART 3\r\n[表达式](https://www.luogu.com.cn/problem/P7073)\r\n\r\n~~考场上的我，年少轻狂，自以为想出了二叉树就能拿满，结果成为这次考试最大的遗憾~~，然后65分。\r\n\r\n本蒟蒻不喜欢字符串，非常不喜欢字符串，~~想当年做中缀表达式求值一类的字符串题时痛苦的不得了。~~\r\n\r\n于是，这道题也不例外。\r\n\r\n写了半天读入字符串的代码，有绕了半天求值。的确，我把那棵二叉树建出来了，但我估计是写法的常数复杂度太高，于是炸掉了。\r\n\r\n相比于去年第三题的变型背包[纪念品](https://www.luogu.com.cn/problem/P5662)，今年的第三题难了不少。\r\n\r\n贴上代码，虽然有点不好意思，但那也是我辛辛苦苦写出来的，这道题的代码我删了freopen，并加了一些注释，以方便大家理解当时的我的做法：\r\n\r\n```cpp\r\n#include<cstdio>\r\n#include<stack>\r\n#define N 100005\r\nusing namespace std;\r\n\r\nbool a[N];\r\nint m,q,e[N*10],ere[N],top,root;\r\n//在e数组中，0代表!，-1代表&，-2代表|，正整数代表x的下标 \r\n\r\nchar w;\r\nint read(){\r\n    char in=getchar();\r\n    if(in=='\\n')return -1;//读到回车返回-1 \r\n    while(in==' ')in=getchar();//过滤掉多余空格 \r\n    if(in!='x'){//如果是二元运算符返回0 \r\n        w=in;\r\n        return 0;\r\n    }\r\n    else{//否则返回这个xi代表的i \r\n        int b=0;\r\n        in=getchar();//丢弃'x'字符 \r\n        while(in>='0'&&in<='9'){//当读到数字时重复 \r\n            b*=10;\r\n            b+=(in-'0');\r\n            in=getchar();\r\n        }\r\n        return b;\r\n    }\r\n}\r\n\r\nstruct tree{\r\n    int data,lc,rc,fa;\r\n}t[N*10];\r\nstack<int>zt;\r\nbool f[N*10];//f[i]代表第i个部分为树根的子树的初值 \r\nvoid dfs(int wh){\r\n    if(e[wh]>0){\r\n        f[wh]=a[e[wh]];\r\n        return;\r\n        //如果是数字，直接返回它的值 \r\n    }\r\n    if(e[wh]==0){//如果是！运算，返回取反后的左子树的值 \r\n        dfs(t[wh].lc);\r\n        f[wh]=!f[t[wh].lc];\r\n    }\r\n    else if(e[wh]==-1){//如果是&运算 \r\n        dfs(t[wh].lc);\r\n        dfs(t[wh].rc);\r\n        f[wh]=f[t[wh].lc]&&f[t[wh].rc];\r\n    }\r\n    else{//如果是|运算 \r\n        dfs(t[wh].lc);\r\n        dfs(t[wh].rc);\r\n        f[wh]=f[t[wh].lc]||f[t[wh].rc];\r\n    }\r\n    return;\r\n}\r\n\r\n//find_ans(wh,last,l_d)  代表现在要求以wh为根节点的树的值的位置\r\n//并且上一棵子树的根节点为last，上一棵子树的值为l_d \r\nbool find_ans(int wh,int last,bool l_d){\r\n    if(wh==0)return l_d;//如果wh为0，意味着它是根节点的父亲，直接返回l_d \r\n    if(e[wh]==0){\r\n        return find_ans(t[wh].fa,wh,!l_d);\r\n        //如果是!运算，直接返回取反后的被影响过的子树的值 \r\n    }\r\n    if(e[wh]==-1){//如果是&运算 \r\n        int ch=t[wh].lc,other=t[wh].rc;\r\n        //ch为变化过的子树的根，other是没变过的 \r\n        if(ch!=last)ch=t[wh].rc,other=t[wh].lc;\r\n        //如果发现ch不等于带过来的last，交换 \r\n        return find_ans(t[wh].fa,wh,f[other]&&l_d);\r\n    }\r\n    if(e[wh]==-2){//如果是|运算 \r\n        int ch=t[wh].lc,other=t[wh].rc;\r\n        if(ch!=last)ch=t[wh].rc,other=t[wh].lc;\r\n        //同上 \r\n        return find_ans(t[wh].fa,wh,f[other]||l_d);\r\n    }\r\n}\r\n\r\nint main(){\r\n\r\n    int r=read();//输入表达式的第一个部分 \r\n    while(r!=-1){//当表达式没到回车时 \r\n        if(r>0){//如果是数字 \r\n            e[++top]=r;\r\n            ere[r]=top;\r\n            //ere[i]代表xi在e数组里的下标 \r\n        }\r\n        if(r==0){//如果是运算符 \r\n            if(w=='!')e[++top]=0;\r\n            else if(w=='&')e[++top]=-1;\r\n            else if(w=='|')e[++top]=-2;\r\n        } \r\n        r=read();\r\n    }\r\n\r\n    int in;\r\n    scanf(\"%d\",&m);\r\n    for(int i=1;i<=m;i++){\r\n        scanf(\"%d\",&in);\r\n        if(in==1)a[i]=true;\r\n        else a[i]=false;\r\n    }//读入每个变量的初值，xi的初值为a[i] \r\n\r\n    //建树 \r\n    for(int i=1;i<=top;i++){//遍历每一个部分 \r\n        t[i].data=e[i];//记录第i个节点的data \r\n        if(e[i]<=0){//如果是运算符 \r\n            if(e[i]==0){//如果是！运算 \r\n                int now=zt.top();\r\n                zt.pop(); \r\n                t[now].fa=i;\r\n                t[i].lc=now;\r\n                //则栈顶元素的父亲是该元素 \r\n            }\r\n            else{//如果是&或|运算 \r\n                int s1=zt.top();\r\n                zt.pop();\r\n                int s2=zt.top();\r\n                zt.pop();\r\n                t[s1].fa=t[s2].fa=i;\r\n                t[i].lc=s1;\r\n                t[i].rc=s2;\r\n                //则栈顶的两个元素的父亲都是该元素 \r\n            }\r\n        }\r\n        zt.push(i);//把该元素的下标压栈 \r\n    }\r\n\r\n    for(int i=1;i<=top;i++){\r\n        if(t[i].fa<=0){\r\n            root=i;\r\n            break;\r\n            //找到一个父亲为初始值（0）的节点\r\n            //那么它就是根节点，等会进行dfs求初值时要用 \r\n        }\r\n    }\r\n    dfs(root);//进行dfs求初值 \r\n\r\n    scanf(\"%d\",&q);\r\n    while(q--){\r\n        int u;//输入每一个问题 \r\n        scanf(\"%d\",&u);\r\n        if(find_ans(t[ere[u]].fa,ere[u],!a[u]))printf(\"1\\n\");\r\n        else printf(\"0\\n\");\r\n        //输出整个表达式的值(即是以根节点为树根的表达式的值) \r\n    }\r\n\r\n    return 0;\r\n}\r\n```\r\n\r\n## PART 4\r\n\r\n[方格取数](https://www.luogu.com.cn/problem/P7074)\r\n\r\n我以为这道题是贪心的做法（毕竟数据规模摆在那里的，基本上要用O(M×N)的算法才能过），然后贪了半天没贪出来，于是乎只能垂头丧气地写了一个爆搜，结果莫名其妙地爆零了。\r\n\r\n啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊\r\n\r\n同班的说这道题很简单，我却直接爆零了！！！\r\n\r\n然后请教了某些大神，发现读错题了，~~把可以向上下右看成可以上下左右了。~~\r\n\r\n~~心情极度郁闷~~，但最后竟然还有5分，也不知道哪里来的。\r\n\r\n我觉得吧，去年最后一题[加工零件](https://www.luogu.com.cn/problem/P5663)对我而言要友好得多，那道题暴力随便50，用了图论或者DP的话要AC也不难。只能说本蒟蒻生不逢时，或者是修炼的不够。\r\n\r\n代码就不贴出来了吧，~~0分代码就不放出来丢人现眼了。~~\r\n\r\n# 总结\r\n从这次考试中还是能说明很多问题的，包括考试技巧、知识掌握等等等等。\r\n\r\n总之，在接下来的一年里努力吧。\r\n\r\nCSP2021提高组见，希望那时的我能比现在的我做得更好。",
      "data": {
        "title": "CSP2020探险记",
        "date": "2022-10-28 08:18:58",
        "tags": [],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "csp2020-tan-xian-ji"
    }
  ],
  "tags": [],
  "menus": []
}